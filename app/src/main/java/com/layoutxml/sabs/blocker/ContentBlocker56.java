package com.layoutxml.sabs.blocker;

import android.content.Context;
import android.content.pm.PackageManager;
import android.support.annotation.Nullable;
import android.util.Log;
import android.util.Patterns;

import com.layoutxml.sabs.App;
import com.layoutxml.sabs.MainActivity;
import com.layoutxml.sabs.db.AppDatabase;
import com.layoutxml.sabs.db.entity.AppInfo;
import com.layoutxml.sabs.db.entity.BlockUrl;
import com.layoutxml.sabs.db.entity.BlockUrlProvider;
import com.layoutxml.sabs.db.entity.UserBlockUrl;
import com.layoutxml.sabs.db.entity.WhiteUrl;
import com.layoutxml.sabs.fragments.BlockerFragment;
import com.layoutxml.sabs.utils.BlockUrlPatternsMatch;
import com.sec.enterprise.AppIdentity;
import com.sec.enterprise.firewall.DomainFilterRule;
import com.sec.enterprise.firewall.Firewall;
import com.sec.enterprise.firewall.FirewallResponse;
import com.sec.enterprise.firewall.FirewallRule;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Arrays;

import javax.inject.Inject;

import static com.layoutxml.sabs.Global.BlockPort53;
import static com.layoutxml.sabs.Global.BlockPortAll;

/*
A good chunk of code is generated by mmotti https://github.com/mmotti
and
fusionjack https://github.com/fusionjack/Adhell2
 */

public class ContentBlocker56 implements ContentBlocker {
    private static ContentBlocker56 mInstance = null;
    private final String TAG = ContentBlocker56.class.getCanonicalName();

    @Nullable
    @Inject
    Firewall mFirewall;
    @Inject
    AppDatabase appDatabase;

    private ContentBlocker56() {
        App.get().getAppComponent().inject(this);
    }

    public static ContentBlocker56 getInstance() {
        if (mInstance == null) {
            mInstance = getSync();
        }
        return mInstance;
    }

    private static synchronized ContentBlocker56 getSync() {
        if (mInstance == null) {
            mInstance = new ContentBlocker56();
        }
        return mInstance;
    }

    @Override
    public boolean enableBlocker() {
        if (isEnabled()) {
            disableBlocker();
        }
        //CustomWhitelist whiteUrlsString
        Log.d(TAG, "Blocker: CW");
        List<WhiteUrl> whiteUrls = appDatabase.whiteUrlDao().getAll2();
        List<String> whiteUrlsString = new ArrayList<>();
        for (WhiteUrl whiteUrl : whiteUrls) {
            whiteUrlsString.add(whiteUrl.url);
        }

        //Blacklist denyList
        Log.d(TAG, "Blocker: B");
        List<String> denyList = new ArrayList<>();
        List<BlockUrlProvider> blockUrlProviders = appDatabase.blockUrlProviderDao().getBlockUrlProviderBySelectedFlag(1);
        for (BlockUrlProvider blockUrlProvider : blockUrlProviders) {
            List<BlockUrl> blockUrls = appDatabase.blockUrlDao().getUrlsByProviderId(blockUrlProvider.id);
            for (BlockUrl blockUrl : blockUrls) {
                if (blockUrl.url.contains("*")) {
                    boolean validWildcard = BlockUrlPatternsMatch.wildcardValid(blockUrl.url);
                    if (validWildcard)
                    {
                        Boolean fits = true;
                        for (String white : whiteUrlsString)
                        {
                            if (blockUrl.url.equals(white))
                                fits=false;
                        }
                        if (fits)
                            denyList.add(blockUrl.url);
                    }
                } else {
                    blockUrl.url = blockUrl.url.replaceAll("^(www)([0-9]{0,3})?(\\.)", "");
                    boolean validDomain = BlockUrlPatternsMatch.domainValid(blockUrl.url);
                    if (validDomain)
                    {
                        Boolean fits = true;
                        for (String white : whiteUrlsString)
                        {
                            if (blockUrl.url.equals(white))
                                fits=false;
                        }
                        if (fits)
                            denyList.add("*" + blockUrl.url + "*");
                    }
                }
            }
        }

        //CustomBlacklist ^
        Log.d(TAG, "Blocker: CB");
        List<UserBlockUrl> userBlockUrls = appDatabase.userBlockUrlDao().getAll2();
        if (userBlockUrls != null && userBlockUrls.size() > 0) {
            for (UserBlockUrl userBlockUrl : userBlockUrls) {
                userBlockUrl.url = userBlockUrl.url.replaceAll("^(www)([0-9]{0,3})?(\\.)", "");
                final String urlReady = "*" + userBlockUrl.url + "*";
                denyList.add(urlReady);
            }
        }

        //Finished rules
        Log.d(TAG, "Blocker: FR");
        List<DomainFilterRule> rules = new ArrayList<>();
        AppIdentity appIdentity = new AppIdentity("*", null);
        int begin=0, end=2000; //Why 2000? I don't know. Just playing safe.
        while (begin!=end)
        {
            rules.add(new DomainFilterRule(appIdentity, denyList.subList(begin,end), new ArrayList<>()));
            begin=end;
            if (end+2000<=denyList.size())
                end+=2000;
            else
                end=denyList.size();
        }
        List<String> superAllow = new ArrayList<>();
        superAllow.add("*");
        List<AppInfo> appInfos = appDatabase.applicationInfoDao().getWhitelistedApps();
        for (AppInfo app : appInfos) {
            rules.add(new DomainFilterRule(new AppIdentity(app.packageName, null), new ArrayList<>(), superAllow));
        }

        //Port53
        Log.d(TAG, "Blocker: P53");
        try {
            if(BlockPort53)
            {
                Log.d(TAG, "BLOCKING PORT 53");
                if (BlockPortAll)
                {
                    Log.d(TAG, "BLOCKING PORT 53 on all apps");
                    FirewallRule[] portRules = new FirewallRule[2];
                    portRules[0] = new FirewallRule(FirewallRule.RuleType.DENY, Firewall.AddressType.IPV4);
                    portRules[0].setIpAddress("*");
                    portRules[0].setPortNumber("53");
                    portRules[1] = new FirewallRule(FirewallRule.RuleType.DENY, Firewall.AddressType.IPV6);
                    portRules[1].setIpAddress("*");
                    portRules[1].setPortNumber("53");
                    assert mFirewall != null;
                    FirewallResponse[] response = mFirewall.addRules(portRules);
                } else
                {
                    Log.d(TAG, "BLOCKING PORT 53 on Chrome only");
                    FirewallRule[] portRules = new FirewallRule[2];
                    List<String> Port53Apps = new ArrayList<>(Arrays.asList("com.android.chrome", "com.chrome.beta", "com.chrome.dev", "com.chrome.canary"));
                    for (String app : Port53Apps) {
                        portRules[0] = new FirewallRule(FirewallRule.RuleType.DENY, Firewall.AddressType.IPV4);
                        portRules[0].setIpAddress("*");
                        portRules[0].setPortNumber("53");
                        portRules[0].setApplication(new AppIdentity(app, null));
                        portRules[1] = new FirewallRule(FirewallRule.RuleType.DENY, Firewall.AddressType.IPV6);
                        portRules[1].setIpAddress("*");
                        portRules[1].setPortNumber("53");
                        portRules[1].setApplication(new AppIdentity(app, null));
                    }
                    assert mFirewall != null;
                    FirewallResponse[] response = mFirewall.addRules(portRules);
                }
            }
        }
        catch (SecurityException ex)
        {
            return false;
        }

        //Final blocking
        Log.d(TAG, "Blocker: FB");
        try {
            Boolean allResponses = true;
            begin=0;
            end=1;
            while(begin!=end)
            {
                Log.d(TAG, "Blocker: FBn");
                FirewallResponse[] response = mFirewall.addDomainFilterRules(rules.subList(begin,end));
                if (FirewallResponse.Result.FAILED == response[0].getResult())
                {
                    allResponses=false;
                }
                begin=end;
                if (end+1<=rules.size())
                    end+=1;
                else
                    end=rules.size();
            }
            if (!mFirewall.isFirewallEnabled()) {
                mFirewall.enableFirewall(true);
            }
            if (!mFirewall.isDomainFilterReportEnabled()) {
                mFirewall.enableDomainFilterReport(true);
            }
            return allResponses;
        }
        catch (SecurityException ex) {
            Log.d(TAG, "Blocker: FAILED2");
            return false;
        }
    }

    @Override
    public boolean disableBlocker() {
        FirewallResponse[] response;
        try {
            assert mFirewall != null;
            response = mFirewall.clearRules(Firewall.FIREWALL_ALL_RULES);
            response = mFirewall.removeDomainFilterRules(DomainFilterRule.CLEAR_ALL);
            if (mFirewall.isFirewallEnabled()) {
                mFirewall.enableFirewall(false);
            }
            if (mFirewall.isDomainFilterReportEnabled()) {
                mFirewall.enableDomainFilterReport(false);
            }
        } catch (SecurityException ex) {
            return false;
        }
        return true;
    }

    @Override
    public boolean isEnabled() {
        assert mFirewall != null;
        return mFirewall.isFirewallEnabled();
    }

}
